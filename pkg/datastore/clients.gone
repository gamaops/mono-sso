package datastore

import (
	"context"

	"time"

	"errors"

	sso "github.com/gamaops/mono-sso/pkg/idl/sso-manager"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

type ClientDoc struct {
	ID           *primitive.ObjectID `bson:"_id,omitempty"`
	Name         string              `bson:"name" validate:"required" json:"name"`
	Secret       string              `bson:"secret"`
	RedirectURIs []string            `bson:"redirect_uris" validate:"required,min=1" json:"redirect_uris"`
	Type         sso.ClientType      `bson:"type" validate:"min=0,max=1" json:"type"`
	CreatedAt    time.Time           `bson:"created_at"`
	UpdatedAt    time.Time           `bson:"updated_at,omitempty"`
	DeletedAt    *time.Time          `bson:"deleted_at,omitempty"`
}

func (c *ClientDoc) FromUpsertClientRequest(req *sso.UpsertClientRequest) {
	c.RedirectURIs = req.RedirectUris
	c.Name = req.Name
	c.Type = req.Type
}

var ErrClientNotFound = errors.New("client not found")

func (d *Datastore) UpsertClient(ctx context.Context, req *sso.UpsertClientRequest) (*ClientDoc, error) {

	tx, err := d.Client.BeginTx(ctx, nil)
	if err != nil {
		d.Logger.Errorf("Error when starting transaction: %v", err)
		return nil, err
	}

	err = session.StartTransaction()
	if err != nil {
		d.Logger.Errorf("Error when starting MongoDB transaction: %v", err)
		return nil, err
	}
	defer session.EndSession(ctx)

	var client *ClientDoc

	err = mongo.WithSession(ctx, session, func(sc mongo.SessionContext) error {

		if len(req.ClientId) > 0 {
			clientID, err := primitive.ObjectIDFromHex(req.ClientId)
			if err != nil {
				d.Logger.Errorf("Error when converting client ID to object ID: %v", err)
				return err
			}
			client = d.FindClientByID(sc, &clientID)
			if client == nil {
				return ErrClientNotFound
			}
			prevUpdatedAt := client.UpdatedAt
			client.UpdatedAt = time.Unix(req.Session.Timestamp, 0)
			if prevUpdatedAt.Unix() >= client.UpdatedAt.Unix() {
				return ErrVersionMismatch
			}
			client.FromUpsertClientRequest(req)
			err = d.Options.Validator.Struct(client)
			if err != nil {
				return err
			}
			result, err := d.Collections.Clients.UpdateOne(sc, bson.M{"_id": client.ID}, bson.M{
				"$set": client,
			})
			if err != nil {
				return err
			}
			if result.MatchedCount != 1 || result.ModifiedCount != 1 {
				return ErrClientNotFound
			}
			return nil
		}

		client = &ClientDoc{}
		client.FromUpsertClientRequest(req)
		client.CreatedAt = time.Unix(req.Session.Timestamp, 0)
		client.UpdatedAt = client.CreatedAt

		// TODO: Generate secret

		err = d.Options.Validator.Struct(client)
		if err != nil {
			return err
		}

		result, err := d.Collections.Clients.InsertOne(sc, client)

		if err != nil {
			return err
		}

		clientID := result.InsertedID.(primitive.ObjectID)
		client.ID = &clientID

		err = session.CommitTransaction(sc)
		if err != nil {
			return err
		}

		return nil
	})

	session.EndSession(ctx)

	if err != nil {
		return nil, err
	}

	return client, nil

}
